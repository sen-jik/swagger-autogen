<%
/** 
* @description Tanstack Query - Query 생성 템플릿 입니다.
*/

const { utils, route, modelTypes, config } = it;
const { pascalCase, internalCase: camelCase, _: lodash } = utils;
const { moduleName, routes } = route;

// 유틸리티 함수들
const removeBracket = (type) => type.replace(/[()]/g, '');

const cleanupType = (type) => {
    return type
      // 배열 타입 주변의 불필요한 괄호 제거
      .replace(/\(([A-Za-z0-9_]+)\)(\[\])/g, '$1$2')
      
      // 속성 뒤의 불필요한 공백 제거 (콤마 앞의 공백 제거)
      .replace(/\s+,/g, ',')
      
      // 배열 타입 뒤의 콤마와 공백 제거
      .replace(/(\[\]),\s*/g, '$1')
      
      // 객체 끝의 불필요한 공백 제거
      .replace(/\s+}/g, '}')
      
      // 객체 시작의 불필요한 공백 제거
      .replace(/{\s+/g, '{')
      
      // 연속된 공백 제거
      .replace(/\s{2,}/g, ' ');
  };

// 경로 관련 함수들
const getFunctionName = ({ request: { method, path } }) => {
  const segments = path.split('/').map(segment => {
    if (segment.includes('${')) {
      return `By_${segment.replace(/[${}]/g, '')}`;
    }
    return segment;
  });
  
  return `${method}${pascalCase(segments.join('_'))}`;
};

const buildQueryKey = ({ path }) => {
  return path
    .split('/')
    .filter(segment => segment && segment !== 'api')
    .map(segment => {
      if (segment.match(/\${/)) {
        return segment.replace(/[${}]/g, '').toUpperCase().replace(/-/g, '_');
      }
      return segment.toUpperCase().replace(/-/g, '_');
    })
    .join('_');
};

const buildPathQueryKey = ({ path }) => {
  return path
    .split('/')
    .filter(segment => segment && segment !== 'api')
    .map(segment => {
      if (segment.match(/\${/)) {
        return segment.replace(/[${}]/g, '').replace(/-/g, '_');
      }
      return `'${segment.replace(/-/g, '_')}'`;
    });
};

// 요청 파라미터 생성 함수
const getRequestParams = ({ parameters = [], query, payload, routeName }) => {
  const queryParamsDto = query ? `${pascalCase(routeName.usage)}QueryParams` : '';

  const paramsWithTypes = lodash.compact([
    ...parameters.map(({ name, type, optional }) => 
      `${name}${optional ? '?' : ''}: ${removeBracket(type)}`
    ),
    queryParamsDto ? `params${query.optional ? '?' : ''}: ${queryParamsDto}` : '',
    payload ? `body${payload.optional ? '?' : ''}: ${removeBracket(payload.type)}` : '',
  ]).join(', ');

  const paramsWithoutTypes = lodash.compact([
    ...parameters.map(({ name, optional }) => `${name}${optional ? '?' : ''}`),
    query ? 'params' : '',
    payload ? 'body' : '',
  ]).join(', ');

  return {
    withTypes: paramsWithTypes,
    withoutTypes: paramsWithoutTypes
  };
};

// 쿼리 설정 생성
const queryConfigs = routes
  .filter(({ request: { method } }) => method === 'get')
  .map(route => {
    const functionName = getFunctionName(route);
    const { request, response } = route;
    const queryKeyName = buildQueryKey(request);
    const pathQueryKey = buildPathQueryKey(request);
    
    const { withTypes: requestParams, withoutTypes: requestParamsWithoutTypes } = 
      getRequestParams({
        ...request,
        routeName: route.routeName
      });

    const queryKeyParams = [
      ...pathQueryKey,
      request.query ? 'params' : null,
      request.payload ? 'data' : null,
    ].filter(Boolean).join(', ');

    return {
      moduleName,
      route,
      functionName: camelCase(functionName),
      hookName: camelCase(`use${pascalCase(functionName)}Query`),
      suspenseHookName: camelCase(`use${pascalCase(functionName)}SuspenseQuery`),
      responseDto: cleanupType(response.type),
      requestParams,
      requestParamsWithoutTypes,
      queryKeyName: `GET_${queryKeyName}`,
      queryKey: `(${requestParams}) => [${queryKeyParams}]`,
    };
  });

const builtInTypes = new Set([
  'string',
  'number',
  'boolean',
  'unknown',
  'any',
  'null',
  'undefined',
  'Date',
  'File',
  'Blob',
  'Array',
  'Record',
  'Promise',
]);

const extractDtoTypes = (type = '') => {
  return [...new Set((type.match(/\b[A-Z][A-Za-z0-9_]*\b/g) || []))]
    .filter((name) => !builtInTypes.has(name));
};

const dtoTypeNames = [...new Set(queryConfigs.flatMap((item) => extractDtoTypes(item.responseDto)))];
%>

<% if (queryConfigs?.length) { %>
import type {
  DefaultError,
  UseQueryOptions,
  UseSuspenseQueryOptions,
  UseInfiniteQueryOptions,
} from '@tanstack/react-query';
import { useQuery, useSuspenseQuery, useInfiniteQuery } from '@tanstack/react-query';

<% if (dtoTypeNames.length > 0) { %>
import type {
<% for (const dtoTypeName of dtoTypeNames) { %>
  <%= dtoTypeName %>,
<% } %>
} from '../../../shared/api/dto';
<% } %>

import { <%~ moduleName %>Api } from './instance';

export const <% ~moduleName.toUpperCase() %>_QUERY_KEY = {
<% for (const queryConfig of queryConfigs) { %>
  <% ~queryConfig.queryKeyName %>: <% ~queryConfig.queryKey %>,
<% } %>
}

const queries = {
<% for (const queryConfig of queryConfigs) { %>
  <% ~queryConfig.functionName %>: (<% ~queryConfig.requestParams %>) => ({
    queryKey: <% ~moduleName.toUpperCase() %>_QUERY_KEY.<% ~queryConfig.queryKeyName %>(<% ~queryConfig.requestParamsWithoutTypes %>),
    queryFn: () => <% ~moduleName %>Api.<% ~queryConfig.functionName %>(<% ~queryConfig.requestParamsWithoutTypes %>)
  }),
<% } %>
}

// ---------------------- Query ------------------------------
<% for (const queryConfig of queryConfigs) { %>
/**
 * Generated by swagger-fsd-gen
 */
export const <%~ queryConfig.hookName %> = <TData = <%~ queryConfig.responseDto %>>(
  <%~ queryConfig.requestParams ? `${queryConfig.requestParams},`:''%>
  options?: Omit<UseQueryOptions<<%~ queryConfig.responseDto %>, DefaultError, TData>, 'queryKey' | 'queryFn'>
) => {
  return useQuery({
    ...queries.<% ~queryConfig.functionName %>(<% ~queryConfig.requestParamsWithoutTypes %>),
    ...options,
  });
}

<% } %>

// ------------------ Suspense Query --------------------------
<% for (const queryConfig of queryConfigs) { %>
/**
 * Generated by swagger-fsd-gen
 */
export const <%~ queryConfig.suspenseHookName %> = <TData = <%~ queryConfig.responseDto %>>(
  <%~ queryConfig.requestParams ? `${queryConfig.requestParams},`:''%>
  options?: Omit<UseSuspenseQueryOptions<<%~ queryConfig.responseDto %>, DefaultError, TData>, 'queryKey' | 'queryFn'>
) => {
  return useSuspenseQuery({
    ...queries.<% ~queryConfig.functionName %>(<% ~queryConfig.requestParamsWithoutTypes %>),
    ...options,
  });
}

<% } %>

// ------------------ Infinite Query --------------------------
<%
const infiniteQueryConfigs = queryConfigs.filter(config => {
  // Check if query has pagination params
  const queryParams = config.route.request.query?.properties || [];
  return queryParams.some(prop =>
    ['page', 'cursor', 'offset', 'pageToken'].includes(prop.name)
  );
});

for (const queryConfig of infiniteQueryConfigs) {

  // Detect pagination parameter
  const queryParams = queryConfig.route.request.query.properties;
  const paginationParam = queryParams.find(p =>
    ['page', 'cursor', 'offset', 'pageToken'].includes(p.name)
  );

  const paginationType = paginationParam.name; // 'page' | 'cursor' | 'offset' | 'pageToken'

  // Generate appropriate getNextPageParam logic
  let nextPageLogic = '';
  if (paginationType === 'page') {
    nextPageLogic = `
    if (!lastPage?.hasNext) return undefined;
    return (lastPage?.page ?? 0) + 1;`;
  } else if (paginationType === 'cursor') {
    nextPageLogic = `
    if (!lastPage?.nextCursor) return undefined;
    return lastPage.nextCursor;`;
  } else if (paginationType === 'offset') {
    nextPageLogic = `
    const nextOffset = (lastPage?.offset ?? 0) + (lastPage?.limit ?? 20);
    if (nextOffset >= (lastPage?.total ?? 0)) return undefined;
    return nextOffset;`;
  } else if (paginationType === 'pageToken') {
    nextPageLogic = `
    if (!lastPage?.nextPageToken) return undefined;
    return lastPage.nextPageToken;`;
  }

  // Generate getPreviousPageParam logic
  let prevPageLogic = '';
  if (paginationType === 'page') {
    prevPageLogic = `
    if ((firstPage?.page ?? 1) <= 1) return undefined;
    return (firstPage?.page ?? 1) - 1;`;
  } else if (paginationType === 'offset') {
    prevPageLogic = `
    const prevOffset = (firstPage?.offset ?? 0) - (firstPage?.limit ?? 20);
    if (prevOffset < 0) return undefined;
    return prevOffset;`;
  } else {
    prevPageLogic = `
    return undefined; // cursor/token pagination doesn't support backward navigation`;
  }

  // Generate hook name
  const infiniteHookName = queryConfig.hookName.replace('Query', 'InfiniteQuery');

  // Get params without pagination param
  const requestParamsWithoutPagination = queryConfig.requestParams
    .split(',')
    .filter(p => !p.includes('params'))
    .join(', ');

  const requestParamsWithoutTypesNoPagination = queryConfig.requestParamsWithoutTypes
    .split(',')
    .filter(p => p !== 'params')
    .join(', ');
%>

/**
 * Generated by swagger-fsd-gen
 * @description Infinite query for pagination
 */
export const <%~ infiniteHookName %> = <TData = <%~ queryConfig.responseDto %>>(
  <%~ requestParamsWithoutPagination ? `${requestParamsWithoutPagination},` : '' %>
  options?: Omit<UseInfiniteQueryOptions<<%~ queryConfig.responseDto %>, DefaultError, TData>, 'queryKey' | 'queryFn' | 'initialPageParam' | 'getNextPageParam'>
) => {
  return useInfiniteQuery({
    queryKey: <% ~moduleName.toUpperCase() %>_QUERY_KEY.<% ~queryConfig.queryKeyName %>(<% ~requestParamsWithoutTypesNoPagination %><% if (requestParamsWithoutTypesNoPagination) { %>, <% } %>params),
    queryFn: ({ pageParam }) => {
      return <% ~moduleName %>Api.<% ~queryConfig.functionName %>(<% if (requestParamsWithoutTypesNoPagination) { %><% ~requestParamsWithoutTypesNoPagination %>, <% } %>{ ...params, <%= paginationType %>: pageParam });
    },
    initialPageParam: <%= paginationType === 'page' ? '1' : paginationType === 'offset' ? '0' : 'undefined' %> as any,
    getNextPageParam: (lastPage, allPages) => {<%~ nextPageLogic %>
    },
    getPreviousPageParam: (firstPage, allPages) => {<%~ prevPageLogic %>
    },
    ...options,
  });
};

<% } %>
<% } %>
